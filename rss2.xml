<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>永远的万事屋</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>做海贼王的油腻男人</description>
    <pubDate>Wed, 09 Jan 2019 09:26:08 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CAP的小理解</title>
      <link>http://yoursite.com/2019/01/08/2019-1/CAP/</link>
      <guid>http://yoursite.com/2019/01/08/2019-1/CAP/</guid>
      <pubDate>Tue, 08 Jan 2019 08:22:36 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;最近罗胖的“小趋势”很火，这里我也蹭蹭热度，来一个“小理解”。  &lt;/p&gt;
&lt;h3 id=&quot;先聊聊分布式&quot;&gt;&lt;a href=&quot;#先聊聊分布式&quot; class=&quot;headerlink&quot; title=&quot;先聊聊分布式&quot;&gt;&lt;/a&gt;先聊聊分布式&lt;/h3&gt;&lt;p&gt;其实对于分布式我原来一直是
        
      
      </description>
      
      <content:encoded><![CDATA[<p>最近罗胖的“小趋势”很火，这里我也蹭蹭热度，来一个“小理解”。  </p><h3 id="先聊聊分布式"><a href="#先聊聊分布式" class="headerlink" title="先聊聊分布式"></a>先聊聊分布式</h3><p>其实对于分布式我原来一直是有些疑问的，是关于一致性的，一致性是分布式系统面临的问题，但一个系统如果没有一致性问题，那这个系统到底算不算分布式系统呢？比如说，最简单情况，一个电商系统，是由商品、交易、订单组成的，就是说我完成一个下单，需要调用这些个系统，但是这些系统都是使用的同一个DB，换句话说就是，系统层面进行了切分，但是资源是同一个。发现没有，这些系统之间有rpc、mq，甚至进行了分区（不同地区的机房）。到这里不要疑惑，我们每天接触的绝对是分布式系统，只不过它面临CAP问题只解决了C，AP问题仍在。当它想要区解决AP问题的时候，就会发现C不能保证了，这就是著名的CAP定理。</p><h3 id="我的小疑惑"><a href="#我的小疑惑" class="headerlink" title="我的小疑惑"></a>我的小疑惑</h3><p>关于CAP的解释我这里就不再赘述了，我这里只想聊聊CAP中的“P”。好多文章里都翻译成了“分区容忍”，可能是我的理解能力有问题？总是对这个概念不能很清晰的理解。今天看到阮一峰老师的文章，将P翻译成“分区容错”，有点醍醐灌顶的感觉，容错代表容许错误，这时候已经发生了错误。<br>大多数分布式系统都分布在多个子网络。每个子网络就叫做一个区（partition）。分区错误就是，区间通信失败。我们清楚，网络是不可信的，所以分区错误肯定会发生。对于分区错误，最常见的解决办法是Replication，这样即使分区之间发生了异常，有会有其他的节点提供服务，增强了可用性，但是这样又会带来一致性问题。所以，也传说着这样一句话，<strong>P（分区容错）是一定要保证的</strong>（虽然绝大多数根本做不到(●’◡’●)）。  </p><h3 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h3><p>然后我们思考下P的重要性，试思考下，如果不分区，可能会出现什么问题？很明显，如果发生任何外部因素，例如断电、电缆断掉等等，将导致你的系统不可用，这对于互联网行业来说是不能容忍的。在此基础上我们再考虑CA的问题。认真推导就会发现，<strong>在P的情况下，CA不可能同时保证</strong>。<br>然后我们聊聊关系型数据库，很多的文章都会说关系型数据库是CA模型，在大数据的情况下，关系型数据库面临最大的问题是扩展问题，扩展成多库存储，必然导致CA问题，而我们也清楚，分布式事务是很头疼的，而且至今也没有完美的解决方案。<br>推荐两篇不错的文章，<a href="https://www.jdon.com/bigdata/how-to-understand-cap.html" target="_blank" rel="noopener">https://www.jdon.com/bigdata/how-to-understand-cap.html</a>，<a href="http://www.ruanyifeng.com/blog/2018/07/cap.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/cap.html</a></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2019/01/08/2019-1/CAP/#disqus_thread</comments>
    </item>
    
    <item>
      <title>mysql lock</title>
      <link>http://yoursite.com/2018/09/30/2018-9/mysql%20lock/</link>
      <guid>http://yoursite.com/2018/09/30/2018-9/mysql%20lock/</guid>
      <pubDate>Sun, 30 Sep 2018 09:01:36 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;锁级别&quot;&gt;&lt;a href=&quot;#锁级别&quot; class=&quot;headerlink&quot; title=&quot;锁级别&quot;&gt;&lt;/a&gt;锁级别&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;表级锁&lt;br&gt;表级锁的开销小，加锁快，不会出现死锁，锁定粒度大，大概率发生锁的冲突，并发度低。&lt;/li&gt;
&lt;li&gt;行级锁&lt;br&gt;行级锁的开销大，加锁满，会出现死锁，锁定粒度小，小概率发生锁的重读，并发度高。&lt;/li&gt;
&lt;li&gt;页级锁&lt;br&gt;支持页级锁的BDB引擎已经逐渐被InnoDB替代了，这里暂不讨论。  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述特点来看，很难说哪种锁更好，只能相对于所处的业务场景来选择更加适合的锁机制。如果仅从锁的角度来看，表级锁更适合以查询为主的应用场景，而行级锁则更适合于大量按索引条件并发更新少量数据的应用场景。&lt;/p&gt;
&lt;h3 id=&quot;锁模式&quot;&gt;&lt;a href=&quot;#锁模式&quot; class=&quot;headerlink&quot; title=&quot;锁模式&quot;&gt;&lt;/a&gt;锁模式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;共享锁(S)&lt;br&gt;共享锁是他人可以读但不能写&lt;/li&gt;
&lt;li&gt;排他锁(X)&lt;br&gt;排它锁则会阻塞他人的读写操作&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="锁级别"><a href="#锁级别" class="headerlink" title="锁级别"></a>锁级别</h3><ol><li>表级锁<br>表级锁的开销小，加锁快，不会出现死锁，锁定粒度大，大概率发生锁的冲突，并发度低。</li><li>行级锁<br>行级锁的开销大，加锁满，会出现死锁，锁定粒度小，小概率发生锁的重读，并发度高。</li><li>页级锁<br>支持页级锁的BDB引擎已经逐渐被InnoDB替代了，这里暂不讨论。  </li></ol><p>上述特点来看，很难说哪种锁更好，只能相对于所处的业务场景来选择更加适合的锁机制。如果仅从锁的角度来看，表级锁更适合以查询为主的应用场景，而行级锁则更适合于大量按索引条件并发更新少量数据的应用场景。</p><h3 id="锁模式"><a href="#锁模式" class="headerlink" title="锁模式"></a>锁模式</h3><ol><li>共享锁(S)<br>共享锁是他人可以读但不能写</li><li>排他锁(X)<br>排它锁则会阻塞他人的读写操作</li></ol><a id="more"></a><p>为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB还有两种内部使用的<strong>意向锁</strong>（Intention Locks），这两种意向锁都是表锁。<br>意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。<br>意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。<br>上述来看，InnoDB为了实现多粒度锁机制，采用了意向锁。话句话说如果不将表级锁和行级锁有所区别的话，是实现不了多粒度锁机制的。所以我认为意向锁是为了实现锁的层级而发明出来的一种锁。  </p><h4 id="意向锁的作用"><a href="#意向锁的作用" class="headerlink" title="意向锁的作用"></a>意向锁的作用</h4><p>引进意向锁是为了提高封锁子系统的效率。意向锁的含义是：对任一结点加锁时，必须先对它的上层结点加意向锁。引进意向锁后，系统对某一数据对象加锁时不必逐个检查与下一级结点的封锁冲突了。  </p><p>这里说说我的看法，我们平时更新某一条数据，肯定会加一个表的IS锁，然后再对这一行加一个行级排他锁。在互联网中并发更新是最常见的场景，这个时候InnoDB是如何判断有没有锁冲突的呢？答案我们稍微考虑下就知道了，表的意向锁肯定不能够判断出来的，最终还是要到那一行中去判断有没有冲突。所以网上经常说的提高了判断锁冲突的效率，这样我并不能理解。或者说，其实是加了IX锁，这样才可能提高效率，但是我理解IX锁会影响其他事务的写入，难道实我理解不对？？？这里我先记录下来。</p><h3 id="锁的实现方式"><a href="#锁的实现方式" class="headerlink" title="锁的实现方式"></a>锁的实现方式</h3><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><p>由于MySQL的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。  </p><p>当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引或普通索引，InnoDB都会使用行锁来对数据加锁。如果不同的索引碰巧都落到了同一个行上，那么同样会阻塞。  </p><p>即便在条件中使用了索引字段，但是否使用索引来检索数据是由MySQL通过判断不同执行计划的代价来决定的，如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p><p>这里我做一下补充，InnoDB给某一行数据加锁的时候，肯定是给所有能定位到这行数据的所有索引项加锁的，不然同一行数据，根据不同的索引查找到的话，锁就不能生效了。比如说，一个事务根据id更新，另一个事务根据索引更新。</p><p>另外感谢下原作者<a href="https://www.jianshu.com/p/fa28035656a9" target="_blank" rel="noopener">https://www.jianshu.com/p/fa28035656a9</a>、<a href="https://www.jianshu.com/p/325a492a859b" target="_blank" rel="noopener">https://www.jianshu.com/p/325a492a859b</a>。我只是看他们的文章过程中，产生了兴趣和思考。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/09/30/2018-9/mysql%20lock/#disqus_thread</comments>
    </item>
    
    <item>
      <title>由使用mybatis批量插入功能联想到的</title>
      <link>http://yoursite.com/2018/09/13/2018-9/mybatis/</link>
      <guid>http://yoursite.com/2018/09/13/2018-9/mybatis/</guid>
      <pubDate>Thu, 13 Sep 2018 05:59:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;先说说由来&quot;&gt;&lt;a href=&quot;#先说说由来&quot; class=&quot;headerlink&quot; title=&quot;先说说由来&quot;&gt;&lt;/a&gt;先说说由来&lt;/h3&gt;&lt;p&gt;新项目中有批量插入的功能，然而在其他项目中没有找到批量插入的写法，我们都知道，我们使用jdbc的时候是可以指定批量模式的，然而在这里并没有看到我想要的有关批量的设置，所以决定去找找批量使用方式。&lt;/p&gt;
&lt;h3 id=&quot;自己对mybatis的认识过程&quot;&gt;&lt;a href=&quot;#自己对mybatis的认识过程&quot; class=&quot;headerlink&quot; title=&quot;自己对mybatis的认识过程&quot;&gt;&lt;/a&gt;自己对mybatis的认识过程&lt;/h3&gt;&lt;p&gt;查找了不少资料，有细心网友总结的三种方式&lt;a href=&quot;https://blog.csdn.net/m0_37981235/article/details/79131493&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/m0_37981235/article/details/79131493&lt;/a&gt;。不过我认为只有其中的第二种，指定批量模式的才是真正的&lt;strong&gt;批量&lt;/strong&gt;操作。  &lt;/p&gt;
&lt;p&gt;例子中用的SqlSession，SqlSessionTemplate是SqlSession的一个实现，我们可以使用SqlSessionTemplate 来代理以往的DefailtSqlSession完成对数据库的操作，相比于DefaultSqlSession，SqlSessionTemplate是线程安全的，可以被设置成单例的。&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="先说说由来"><a href="#先说说由来" class="headerlink" title="先说说由来"></a>先说说由来</h3><p>新项目中有批量插入的功能，然而在其他项目中没有找到批量插入的写法，我们都知道，我们使用jdbc的时候是可以指定批量模式的，然而在这里并没有看到我想要的有关批量的设置，所以决定去找找批量使用方式。</p><h3 id="自己对mybatis的认识过程"><a href="#自己对mybatis的认识过程" class="headerlink" title="自己对mybatis的认识过程"></a>自己对mybatis的认识过程</h3><p>查找了不少资料，有细心网友总结的三种方式<a href="https://blog.csdn.net/m0_37981235/article/details/79131493" target="_blank" rel="noopener">https://blog.csdn.net/m0_37981235/article/details/79131493</a>。不过我认为只有其中的第二种，指定批量模式的才是真正的<strong>批量</strong>操作。  </p><p>例子中用的SqlSession，SqlSessionTemplate是SqlSession的一个实现，我们可以使用SqlSessionTemplate 来代理以往的DefailtSqlSession完成对数据库的操作，相比于DefaultSqlSession，SqlSessionTemplate是线程安全的，可以被设置成单例的。</p><a id="more"></a><p>SqlSession可以理解成jdbc的connection，平时我们写jdbc的使用是使用connection来操作事务的：  </p><pre><code>try{    con.setAutoCommit(false);    preparedStatement.executeUpdate();    con.commit();}finally{    con.rollback();}</code></pre><p>但是在mybatis中我是不建议这样使用的事务的，当然DefaultSqlSession也支持这种类似的操作，查看mybatis的官方文档中，使用TransactionManager管理事务：  </p><pre><code>DefaultTransactionDefinition def = new DefaultTransactionDefinition();def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);TransactionStatus status = txManager.getTransaction(def);try {  userMapper.insertUser(user);}catch (MyException ex) {  txManager.rollback(status);  throw ex;}txManager.commit(status);</code></pre><p>但上述方式还是不够优雅，mybatis如果和IOC容器集成的话，事务都托管给IOC管理，是不支持自己手动管理事务的，看SqlSessionTemplate的源码也能看出来也是这样。<br><img src="https://i.imgur.com/lWYX93K.png" alt=""><br>所以我们在spring的项目中会有类似如下的代码：  </p><pre><code>transactionTemplate.execute(transactionStatus -&gt; {        supplierStoreSkuList.forEach(supplierStoreSku -&gt; {            VenderStoreSkuEntity venderStoreSkuEntity = SupplierStoreSkuBizConvertUtils.convertToVenderStoreSkuEntityFromSupplierStoreSku(supplierStoreSku);            venderStoreSkuMapper.saveSupplierStoreSku(venderStoreSkuEntity);        });        return null;    });</code></pre><p>这样的代码就会好看很多了，TransactionTemplate帮我们管理了事务，包括了事务的开启，事务的提交，事务的回滚。我们看execute内部源码其实也是使用的transactionManager只不过做了一层封装而已：  </p><p><img src="https://i.imgur.com/YCXYI8W.png" alt=""></p><p>我们再来看看TransactionManager是如何管理事务的，  </p><p><img src="https://i.imgur.com/NiRlOmG.png" alt=""></p><p>可以看到，其实内部就是使用的connection，所谓的管理事务，也就是通过connection来做的。</p><h4 id="然后我们再聊聊mapper"><a href="#然后我们再聊聊mapper" class="headerlink" title="然后我们再聊聊mapper"></a>然后我们再聊聊mapper</h4><p>我们回头再看一下jdbc写的事务：  </p><p><img src="https://i.imgur.com/GNtIXtS.png" alt=""></p><p>我们可以看到红线圈起来的部分都是transctionManager做了，那么preparedStatement的事情谁做了呢？很容易就想到这个是mapper做的事情嘛。代码中获取mapper的方式是这样的：  </p><pre><code>UserMapper userMapper = sqlSessionTemplate.getMapper(UserMapper.class);</code></pre><p>从这种使用方式可以窥见，肯定是通过sqlSession来实现的，我们来看看sqlSession的实现DefaultSqlSession，  </p><p><img src="https://i.imgur.com/i1TULEd.png" alt=""></p><p>里面有Excetor，再看看Excetor是什么样的，  </p><p><img src="https://i.imgur.com/dfQ94GG.png" alt=""></p><p>我们又闻到了熟悉的味道，Statement、prepareStatement。至此可以知道了mybatis是如何映射jdbc的了。</p><h4 id="再看看我项目中的配置"><a href="#再看看我项目中的配置" class="headerlink" title="再看看我项目中的配置"></a>再看看我项目中的配置</h4><p><img src="https://i.imgur.com/3F4NAns.png" alt=""></p><p>其实最开始就已经指定了一个SqlSessionTemplate，所以我们才可以再项目中如下使用而没有问题，  </p><p><img src="https://i.imgur.com/qKfV4d9.png" alt=""></p><h3 id="最后说一下mybatis-batch是如何做的"><a href="#最后说一下mybatis-batch是如何做的" class="headerlink" title="最后说一下mybatis batch是如何做的"></a>最后说一下mybatis batch是如何做的</h3><pre><code>applyTransactionTemplate.execute(transactionStatus -&gt; {    // 指定batch模型的sqlSessionTemplate    SqlSessionTemplate sqlSessionTemplate =  new SqlSessionTemplate(applySqlSessionFactory, ExecutorType.BATCH);    VenderSkuApplyMapper venderSkuApplyBatchMapper = sqlSessionTemplate.getMapper(VenderSkuApplyMapper.class);    for(VenderSkuApplyEntity venderSkuApplyEntity : venderSkuApplyEntities){        venderSkuApplyBatchMapper.insert(venderSkuApplyEntity);    }    sqlSessionTemplate.flushStatements();    return null;});</code></pre><p>其实就是指定了单独batch模式的SqlSessionTemplate。</p><h4 id="还有一点关于flushStatements的疑问"><a href="#还有一点关于flushStatements的疑问" class="headerlink" title="还有一点关于flushStatements的疑问"></a>还有一点关于flushStatements的疑问</h4><p>查看mybatis官方文档，看到了flushStatements这个方法，</p><p><img src="https://i.imgur.com/wVycNik.png" alt=""></p><p>我们先看一下jdbc的batch是怎么写的，  </p><pre><code>String sql = &quot;insert into t_user(name, mobile, email) values(?,?,?)&quot;;try (Connection conn = dataSource.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql);) {    List&lt;User&gt; users = this.getUsers();    for (User user : users) {       pstmt.setString(1, user.getName());       pstmt.setString(2, user.getMobile());       pstmt.setString(3, user.getEmail());       pstmt.addBatch();    }    pstmt.executeBatch();    conn.commit();  }</code></pre><p>可以看到，其实是有一个addBatch和executeBatch的操作，mybatis的话batch操作会调用BatchExecutor的doUpdate方法，  </p><p><img src="https://i.imgur.com/rPnJ7oN.png" alt=""></p><p>handler.batch内部是这样的，  </p><p><img src="https://i.imgur.com/JpHdxxt.png" alt=""></p><p>其实内部也是调用的statement的addBatch操作。  </p><p>然后我在BatchExecutor的doFlushStatements找到了executeBatch()，  </p><p><img src="https://i.imgur.com/SIZ5MxD.png" alt=""></p><p>在BaseExecutor的源码，发现commit中有这个调用，  </p><p><img src="https://i.imgur.com/kM4u1Hu.png" alt="">  </p><p>而使用IOC容器管理事务最终会调用commit方法，所以最终结论是如果不是我们自己手动管理事务，是我们不需要自己调用flushStatements的，over。  </p><p>还找到了其他人对这个方法使用的解释，<a href="https://blog.csdn.net/y41992910/article/details/53641825" target="_blank" rel="noopener">https://blog.csdn.net/y41992910/article/details/53641825</a>，这个解释也有点奇怪，我没有尝试里面所说的方式，但是感觉这本身就是在一个事务中所做的事情吧，跟flushStatements本身没有关系的吧。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/09/13/2018-9/mybatis/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Proxy</title>
      <link>http://yoursite.com/2018/09/08/2018-9/Proxy/</link>
      <guid>http://yoursite.com/2018/09/08/2018-9/Proxy/</guid>
      <pubDate>Sat, 08 Sep 2018 03:13:14 GMT</pubDate>
      <description>
      
        &lt;h3 id=&quot;先讲讲由来&quot;&gt;&lt;a href=&quot;#先讲讲由来&quot; class=&quot;headerlink&quot; title=&quot;先讲讲由来&quot;&gt;&lt;/a&gt;先讲讲由来&lt;/h3&gt;&lt;p&gt;最近项目中要写一个统一的异常拦截，并且打日志的功能，所以很自然的想到了切面，并且很自然想到了spring的aop。  &lt;/p&gt;
&lt;h3 id=&quot;先讲一个spring的aop&quot;&gt;&lt;a href=&quot;#先讲一个spring的aop&quot; class=&quot;headerlink&quot; title=&quot;先讲一个spring的aop&quot;&gt;&lt;/a&gt;先讲一个spring的aop&lt;/h3&gt;&lt;p&gt;spring有好几种方式使用apo：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用MethodInterceptor&lt;/li&gt;
&lt;li&gt;使用声明式aop（&lt;aop:config&gt;）&lt;/aop:config&gt;&lt;/li&gt;
&lt;li&gt;使用aop注解（@Aspect）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再具体的细节我就不讲了，有很多优秀的文章都讲了如何使用&lt;a href=&quot;https://www.cnblogs.com/jacksonshi/p/5863313.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/jacksonshi/p/5863313.html&lt;/a&gt;，&lt;br&gt;看到这里的时候对aspect产生了兴趣。&lt;/p&gt;
&lt;h3 id=&quot;再讲讲aspect&quot;&gt;&lt;a href=&quot;#再讲讲aspect&quot; class=&quot;headerlink&quot; title=&quot;再讲讲aspect&quot;&gt;&lt;/a&gt;再讲讲aspect&lt;/h3&gt;&lt;p&gt;aspect翻译为切面，和面向对象编程一样有面向切面编程（AOP），目前有一个非常出名的面向切面编程的框架AspectJ，它定义了自己的切面语法，还有自己的织入工具。对于spring来说，其实也是用AspectJ的预发定义了切面的规则，但它背后使用了cglib的动态代理，没有使用AspectJ的织入代码。这里有一篇很不错的文章介绍了AspectJ&lt;a href=&quot;https://juejin.im/entry/5a40abb16fb9a0451e400886&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://juejin.im/entry/5a40abb16fb9a0451e400886&lt;/a&gt;  &lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="先讲讲由来"><a href="#先讲讲由来" class="headerlink" title="先讲讲由来"></a>先讲讲由来</h3><p>最近项目中要写一个统一的异常拦截，并且打日志的功能，所以很自然的想到了切面，并且很自然想到了spring的aop。  </p><h3 id="先讲一个spring的aop"><a href="#先讲一个spring的aop" class="headerlink" title="先讲一个spring的aop"></a>先讲一个spring的aop</h3><p>spring有好几种方式使用apo：  </p><ol><li>使用MethodInterceptor</li><li>使用声明式aop（<aop:config>）</aop:config></li><li>使用aop注解（@Aspect）</li></ol><p>再具体的细节我就不讲了，有很多优秀的文章都讲了如何使用<a href="https://www.cnblogs.com/jacksonshi/p/5863313.html" target="_blank" rel="noopener">https://www.cnblogs.com/jacksonshi/p/5863313.html</a>，<br>看到这里的时候对aspect产生了兴趣。</p><h3 id="再讲讲aspect"><a href="#再讲讲aspect" class="headerlink" title="再讲讲aspect"></a>再讲讲aspect</h3><p>aspect翻译为切面，和面向对象编程一样有面向切面编程（AOP），目前有一个非常出名的面向切面编程的框架AspectJ，它定义了自己的切面语法，还有自己的织入工具。对于spring来说，其实也是用AspectJ的预发定义了切面的规则，但它背后使用了cglib的动态代理，没有使用AspectJ的织入代码。这里有一篇很不错的文章介绍了AspectJ<a href="https://juejin.im/entry/5a40abb16fb9a0451e400886" target="_blank" rel="noopener">https://juejin.im/entry/5a40abb16fb9a0451e400886</a>  </p><a id="more"></a><h3 id="然后了解下cglib"><a href="#然后了解下cglib" class="headerlink" title="然后了解下cglib"></a>然后了解下cglib</h3><p>cglib本身是一个代码生成库，可以生成字节码。所谓cglib的动态代理就是分析了aspect定义的规则，然后生成了对应的代理类，加载到内存中使用。<br>网上总是拿jdk的动态代理和cglib的动态代理来比较，这里我们也简单的介绍下：  </p><p><strong>JDK动态代理只能对实现了接口的类生成代理，而不能针对类<br>CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法（继承）</strong>  </p><p>talk is cheap,let’s code.下面是我写的一个jdk代理的demo：  </p><pre><code>public class DynamicProxyTest {public static void main(String[] args){    //生成$Proxy0的class文件</code></pre><p>//        System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”);</p><pre><code>    IHello iHello = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(),            new Class[]{IHello.class} ,            new MyInvocationHandler(new Hello()));    iHello.sayHello();}public static interface IHello{    void sayHello();}public static class Hello implements IHello{    @Override    public void sayHello() {        System.out.println(&quot;hello world&quot;);    }}public static class MyInvocationHandler implements InvocationHandler {    Object javaProxy;    public MyInvocationHandler(Object javaProxy) {        this.javaProxy = javaProxy;    }    private void aopMethod() {        System.out.println(&quot;before method&quot;);    }    //继承方法，代理时实际执行的犯法，如果要实现原方法，则需要调用method.invoke(javaProxy, args)，这里还调用了一个aopMethod(),可以类比于Spring中的切面before注解。    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        aopMethod();        return method.invoke(javaProxy, args);    }}}</code></pre><p>这是下面是jdk生成的代理类反编译后的结果：</p><pre><code>public class DynamicProxyTest$MyInvocationHandler    implements InvocationHandler{Object javaProxy;public DynamicProxyTest$MyInvocationHandler(Object javaProxy){    this.javaProxy = javaProxy;}private void aopMethod(){    System.out.println(&quot;before method&quot;);}public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable{    aopMethod();    return method.invoke(this.javaProxy, args);}}</code></pre><p>可以看到InvocationHandler的写法还是最终生成的代理类的代码其实和我们写的静态代理的方式是一样的。</p><p>接下来我们看看cglib的：<br>    public class DynamicProxyCglibTest {</p><pre><code>public static void main(String[] args){    Enhancer enhancer = new Enhancer();    enhancer.setSuperclass(HelloImpl.class);    enhancer.setCallback(new HelloMethodIntercepter());    HelloImpl hello = (HelloImpl)enhancer.create();    hello.sayHello();}public static class HelloImpl {    public void sayHello() {        System.out.println(&quot;hello world&quot;);    }}public static class HelloMethodIntercepter implements MethodInterceptor {    @Override    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {        System.out.println(&quot;before:&quot; + method.getName());        Object object = methodProxy.invokeSuper(o, objects);        System.out.println(&quot;after:&quot; + method.getName());        return object;    }}}</code></pre><p>这是下面是jdk生成的代理类反编译后的结果：  </p><pre><code>public class DynamicProxyCglibTest$HelloMethodIntercepter    implements MethodInterceptor{public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy)        throws Throwable{    System.out.println(&quot;before:&quot; + method.getName());    Object object = methodProxy.invokeSuper(o, objects);    System.out.println(&quot;after:&quot; + method.getName());    return object;}}</code></pre><p>可以看到其实都是大同小异的。我们成天总是将动态代理、静态代理的区别什么的，其实从最根本上说是没什么区别的，都是生成了另一个代理实例，来调用我们真正的实例。只不过动态代理带给我们的方便是不需要我们自己写这个实例而已，由代码生成器去生成罢了。如果是统一的规则应用在很多的类方法，这个时候所谓动态代理就显示了威力，不需要我们去一个个写代理类了，反而言之，如果只有一个类的话，动态代理也就没什么必要了。  </p><p>这里顺便说一下，经常讨论的动态代理的性能不好什么的，我原来的以为是动态代理每次去做都需要生成字节码的，今天了解后才知道不是，根本就是编译的时候就生成放在jvm中了。那么问题来了，如果不是字节码的性能损耗，对于代码来说就跟我们平时写个包装类，也只是多了一层调用而已，不应该有什么损耗的吧。所以所谓动态代理的性能损耗不是指的是代理本身，而是指的动态代理用的反射的损耗。但是一般在spring管理下的实例也是单例的，生成的代理实例应该也是单例，所以也不存在newInstance的损耗，那最终应该就是invoke的损耗了吧。  </p><p>上面是我的推断，后续还要确认，如果异议欢迎来议。</p><p>最后说一下，jdk从1.7之后代理的性能已经超过了cglib了，所以网上说的什么cglib完爆jdk那是很多年前的事情了。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/09/08/2018-9/Proxy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Treap</title>
      <link>http://yoursite.com/2018/08/21/2018-8/Treap/</link>
      <guid>http://yoursite.com/2018/08/21/2018-8/Treap/</guid>
      <pubDate>Tue, 21 Aug 2018 10:47:11 GMT</pubDate>
      <description>
      
        
        
          &lt;h3 id=&quot;Treap是什么&quot;&gt;&lt;a href=&quot;#Treap是什么&quot; class=&quot;headerlink&quot; title=&quot;Treap是什么&quot;&gt;&lt;/a&gt;Treap是什么&lt;/h3&gt;&lt;p&gt;Treap是Tree+Heap，也是一种二叉查找树。它相对于二叉树多了priority的概念
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="Treap是什么"><a href="#Treap是什么" class="headerlink" title="Treap是什么"></a>Treap是什么</h3><p>Treap是Tree+Heap，也是一种二叉查找树。它相对于二叉树多了priority的概念。<br>它具有二叉树和堆的特性：  </p><ol><li>Treap是关于key的二叉排序树（也就是规定的排序方式）。</li><li>Treap是关于priority的堆（按照随机出的优先级作为小根/大根堆)。（非二叉堆，因为不是完全二叉树）</li><li>key和priority确定时，treap唯一。</li></ol><p>Treap依赖于随机数，随机生成的优先级属性，通过简单的左右旋可以将长链旋转成近似完全二叉树结构。</p><h3 id="Treap是如何做到近似完全二叉树的呢？"><a href="#Treap是如何做到近似完全二叉树的呢？" class="headerlink" title="Treap是如何做到近似完全二叉树的呢？"></a>Treap是如何做到近似完全二叉树的呢？</h3><p>拿插入来说，先按照key的大小添加到二叉树上，再按照priority旋转二叉树。因为priority是随机分配的，所以在一定的概率上不容易导致单链条的二叉树，这就是Treap最根本的特点。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/08/21/2018-8/Treap/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
