<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>永远的万事屋</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>做海贼王的油腻男人</description>
    <pubDate>Fri, 13 Apr 2018 14:20:05 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>初识区块链</title>
      <link>http://yoursite.com/2018/04/13/block-chain/</link>
      <guid>http://yoursite.com/2018/04/13/block-chain/</guid>
      <pubDate>Fri, 13 Apr 2018 13:05:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;首先我们先聊聊最老生常谈的话题，&lt;strong&gt;区块链&lt;/strong&gt;是什么？我在网上找了很多的解释，在这里我推荐一个我认为最好的解释。我们可以换一个角度来问这个问题，与其关心什么是&lt;strong&gt;区块链&lt;/strong&gt;，不如去考虑，满足什么条件就可以称为&lt;strong&gt;区块链&lt;/strong&gt;呢？这里给出三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区块链是一个放在非安全环境中的分布式数据库（系统）&lt;/li&gt;
&lt;li&gt;区块链采用密码学的方法来保证已有数据不可能被篡改&lt;/li&gt;
&lt;li&gt;区块链采用共识算法来对于新增数据达成共识&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;接下来我们来聊聊区块链为什么会这么火？为什么称区块链是一场革命呢？其实就两个字，&lt;strong&gt;信任&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://i.imgur.com/pfW33pD.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;信任是自古以来一直都有的东西，从洞穴时代到工业时代再到信息时代，人们无不依赖于信任来进行交易：&lt;strong&gt;我信任你，我才会和你交易&lt;/strong&gt;。&lt;strong&gt;解决社会因为审核所花费的成本&lt;/strong&gt;，在当今社会中充斥这大量的中介机构（这里的中介机构不光是我们通常理解的房屋中介什么的），我们在京东买东西付款，是因为我们相信京东收到付款后会给我们发货；我们把钱存银行，是因为我们相信银行不会花掉我们的钱等等。思考一下，我们的社会运转其实就是依赖这些中介机构，但另一方面也说明同时我们花费着巨额的成本去证明&lt;strong&gt;“我们之间可以信任”&lt;/strong&gt;。想象一下，去掉这些证明信任的环节，那我们的社会将会是什么样呢？可见称区块链为一场革命是有必要的。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;首先我们先聊聊最老生常谈的话题，<strong>区块链</strong>是什么？我在网上找了很多的解释，在这里我推荐一个我认为最好的解释。我们可以换一个角度来问这个问题，与其关心什么是<strong>区块链</strong>，不如去考虑，满足什么条件就可以称为<strong>区块链</strong>呢？这里给出三点：</p><ol><li>区块链是一个放在非安全环境中的分布式数据库（系统）</li><li>区块链采用密码学的方法来保证已有数据不可能被篡改</li><li>区块链采用共识算法来对于新增数据达成共识</li></ol><hr><p>&emsp;&emsp;接下来我们来聊聊区块链为什么会这么火？为什么称区块链是一场革命呢？其实就两个字，<strong>信任</strong>。<br><img src="https://i.imgur.com/pfW33pD.png" alt=""><br>信任是自古以来一直都有的东西，从洞穴时代到工业时代再到信息时代，人们无不依赖于信任来进行交易：<strong>我信任你，我才会和你交易</strong>。<strong>解决社会因为审核所花费的成本</strong>，在当今社会中充斥这大量的中介机构（这里的中介机构不光是我们通常理解的房屋中介什么的），我们在京东买东西付款，是因为我们相信京东收到付款后会给我们发货；我们把钱存银行，是因为我们相信银行不会花掉我们的钱等等。思考一下，我们的社会运转其实就是依赖这些中介机构，但另一方面也说明同时我们花费着巨额的成本去证明<strong>“我们之间可以信任”</strong>。想象一下，去掉这些证明信任的环节，那我们的社会将会是什么样呢？可见称区块链为一场革命是有必要的。<br><a id="more"></a><br>&emsp;&emsp;然后我们聊聊市面上的区块链。现在区块链有三类：公有链、私有链、联盟链（共同体链）。<br><img src="https://i.imgur.com/Kzg8aDZ.jpg" alt=""><br>市面上现在一直鼓吹的特性（去中心化、解决信任问题），其实是公有链才具备的特征。但是公有链又面临着一个问题，可应用的场景太少，目前除了数字货币、智能合约还没有很成熟的案例。而私有链是和公有链在这点上是完全相对的，失去了公有链最最重要的特征（去中心化），自我感觉其也没有很高的价值。所以现在商业上应用最深的其实是联盟链，它结合了公共区块链的“低信任”和私有区块链的“单一高度信任”来提供了一种混合的模式。而且联盟链才是形态上最符合现在社会情况的，相比于公有链的那种完全去中心化的不可控和隐私安全问题，联盟链变得更灵活，也更有可操作性。当然作为一个极客，我还是很期待完全去中心化的呢。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/13/block-chain/#disqus_thread</comments>
    </item>
    
    <item>
      <title>非对称加密</title>
      <link>http://yoursite.com/2018/04/03/asymmetric-cryptographic/</link>
      <guid>http://yoursite.com/2018/04/03/asymmetric-cryptographic/</guid>
      <pubDate>Tue, 03 Apr 2018 10:19:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;再说“非对称加密”之前，我们先聊一聊“对称加密”。对称加密是我们所熟知的加密，通过加密算法和秘钥将明文加密成密文。其中算法和秘钥都是固定的，也就是说如果我们的算法和秘钥有任何泄露的话，我们的加密也就不再安全。这个是“对称加密”的问题，现在想一下我们真正的使用场景。假设我们是发送端，为了信息的安全，需要把内容加密发送，所以接收端必须要知道加密算法和秘钥，这才可以识别加密内容并使用。这就带来了一个问题，我们的信息安全是建立在信任接收端之上的，相信接收端不会泄露我们的加密算法和秘钥，所以“对称加密”严格来说并不太安全。由于以上“对称加密”的问题，这就催生了“非对称加密”。&lt;br&gt;&amp;emsp;&amp;emsp;“非对称加密”需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;再说“非对称加密”之前，我们先聊一聊“对称加密”。对称加密是我们所熟知的加密，通过加密算法和秘钥将明文加密成密文。其中算法和秘钥都是固定的，也就是说如果我们的算法和秘钥有任何泄露的话，我们的加密也就不再安全。这个是“对称加密”的问题，现在想一下我们真正的使用场景。假设我们是发送端，为了信息的安全，需要把内容加密发送，所以接收端必须要知道加密算法和秘钥，这才可以识别加密内容并使用。这就带来了一个问题，我们的信息安全是建立在信任接收端之上的，相信接收端不会泄露我们的加密算法和秘钥，所以“对称加密”严格来说并不太安全。由于以上“对称加密”的问题，这就催生了“非对称加密”。<br>&emsp;&emsp;“非对称加密”需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。 非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公用密钥向其它方公开；得到该公用密钥的乙方使用该密钥对机密信息进行加密后再发送给甲方；甲方再用自己保存的另一把专用密钥对加密后的信息进行解密。<br><a id="more"></a><br>&emsp;&emsp;另一方面，甲方可以使用乙方的公钥对机密信息进行签名后再发送给乙方；乙方再用自己的私匙对数据进行验签。这是数字签名的使用。数字签名是非对称密钥加密技术与数字摘要技术的应用。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。<br>&emsp;&emsp;“非对称加密”解决了“对称加密”信息安全依赖第三方的问题，当然这个还是建立在自己不会泄露自己的私钥的基础上的。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/04/03/asymmetric-cryptographic/#disqus_thread</comments>
    </item>
    
    <item>
      <title>websocket http</title>
      <link>http://yoursite.com/2018/03/23/http/</link>
      <guid>http://yoursite.com/2018/03/23/http/</guid>
      <pubDate>Fri, 23 Mar 2018 12:52:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;前端时间和斌哥吃饭，我就斌哥他们做游戏用的是什么通信协议，斌哥说他们用的是websocket。关于websocket的名字我也是听说过的，但也只是了解到了它是http之上的协议，也没有做过深入的理解。这两天闲下来写，所以就查找了websocket了的资料。&lt;br&gt;&amp;emsp;&amp;emsp;既然提到了websocket，http就不能绕过去的。websocket的出现就是为了弥补http的不足。我们都知道一个事实，http协议只能由客户端发起，就是说服务器不能主动向客户端发起请求。但是websocket就是一个&lt;strong&gt;全双工&lt;/strong&gt;协议，允许服务器主动发送信息给客户端。websocket本身是html5规范的一部分，就是来解决服务器给浏览器发消息的问题（原来只能依靠不断的轮询服务器才能做到的事情），但websocket也不局限于浏览器的使用，任何实现了websocket协议的客户端和服务端都可以用此通信。那么websocket到底和http有啥关系呢？websocket和http都是从tcp之上演化而来的，对于websocket来说，它依赖了http协议进行一次握手（关于为啥非得用http握手我就不太清楚了，可能是最先html5的规范并且肯定要在浏览器使用的原因吧），握手成功后，数据就从tcp通道传输，与http无关了。&lt;br&gt;&amp;emsp;&amp;emsp;下面我们来聊一聊http，http的历史发展我就不再多说了，网上很多资料写的很清楚，&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;前端时间和斌哥吃饭，我就斌哥他们做游戏用的是什么通信协议，斌哥说他们用的是websocket。关于websocket的名字我也是听说过的，但也只是了解到了它是http之上的协议，也没有做过深入的理解。这两天闲下来写，所以就查找了websocket了的资料。<br>&emsp;&emsp;既然提到了websocket，http就不能绕过去的。websocket的出现就是为了弥补http的不足。我们都知道一个事实，http协议只能由客户端发起，就是说服务器不能主动向客户端发起请求。但是websocket就是一个<strong>全双工</strong>协议，允许服务器主动发送信息给客户端。websocket本身是html5规范的一部分，就是来解决服务器给浏览器发消息的问题（原来只能依靠不断的轮询服务器才能做到的事情），但websocket也不局限于浏览器的使用，任何实现了websocket协议的客户端和服务端都可以用此通信。那么websocket到底和http有啥关系呢？websocket和http都是从tcp之上演化而来的，对于websocket来说，它依赖了http协议进行一次握手（关于为啥非得用http握手我就不太清楚了，可能是最先html5的规范并且肯定要在浏览器使用的原因吧），握手成功后，数据就从tcp通道传输，与http无关了。<br>&emsp;&emsp;下面我们来聊一聊http，http的历史发展我就不再多说了，网上很多资料写的很清楚，<br><a id="more"></a><a href="http://www.360doc.com/content/16/0816/07/30578693_583526011.shtml" title="http的前世今生" target="_blank" rel="noopener">http://www.360doc.com/content/16/0816/07/30578693_583526011.shtml</a>。这里聊聊我的一些困惑。首先现在最最流行的肯定就是http2了，而http2有很多优秀的特性，像服务端推送、header压缩、二进制格式、多路复用等。其他的特性还很容易理解，这里我最困惑的是<strong>多路复用</strong>，因为我知道http1.1就已经有了keep-alive属性，本身已经做到了不是每次都去创建http连接，而是复用上次的连接，而tcp本身的特性也决定了，只能在一次请求完成以后才能进行下一次请求，这也才有了“<strong>head of line blocking</strong>”问题，在我的理解当中，除非tcp本身解决此问题，否则在其之上的更不可能解决的吧？？<br>&emsp;&emsp;在查找资料的过程中，我也了解到了不少知识，http1.1本身也曾试着解决“head of line blocking”问题，所以提出了http piplelining解决方案，但可能其本身提出的并不是和合理，所以各大浏览器厂商支持并不好<a href="http://www.cnblogs.com/gzchenjiajun-php/articles/4992795.html" target="_blank" rel="noopener">http://www.cnblogs.com/gzchenjiajun-php/articles/4992795.html</a>。这更让我想知道http2是如何解决的呢？方式很简单，将消息分解为更小的独立部分（stream）并通过连接发送。其实tcp本身的特性是没变的，只不过是将消息分解成多份，每部分之间不会相互阻塞，原来发送一个大的请求阻塞的其他请求的情况大大减少。requset stream和response stream是在一个tcp连接上交织在一起的，多个stream构成一个完整的request或者response，但是服务器或者浏览器只能处理完整的请求或者响应，不可能处理一部分的，所以还有另一个事情需要浏览器和服务器去做，那就是将stream重新组装，发送给浏览器渲染或者server的handler处理。以下是我的对于http2对request和response处理的理解：<img src="https://i.imgur.com/ZzO0cGi.png" alt="requset、response分解组装"><br><strong><em>特别注意：以上的请求是发生在一个tcp连接上的，以及request的stream和response的stream都是交织的，在这里是想展示分解、组装的过程。</em></strong><br>&emsp;&emsp;这里我提出一点我的疑问，这个分解组装的过程应该也是增大了客户端和服务端的工作量了吧，但可能是这点消耗对于好处来说是无关紧要的吧。以上是我对于http2以及websocket的理解，不对的话欢迎指教。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/23/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>java bean</title>
      <link>http://yoursite.com/2018/03/17/java-bean/</link>
      <guid>http://yoursite.com/2018/03/17/java-bean/</guid>
      <pubDate>Sat, 17 Mar 2018 11:28:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在这里我想聊一个java最基础的java bean的理解。&lt;br&gt;&amp;emsp;&amp;emsp;作为一个java程序员，java bean有get set仿佛是天经地义的。我也是这样认为的。然而经过高人提点，我们仿佛忽略了一个问题，我们一直在使用orm框架，其实set get是orm框架所必须的。其实我们可以看jdk源码，我们能看到jdk的java bean里全有get set吗？明显不是，反而用的多的也是被我们经常忽略的构造函数。&lt;br&gt;&amp;emsp;&amp;emsp;java bean应该有行为吗？答案是肯定的，java是面向对象的语言，java bean的行为正是其面向对象语言的最主要的特征。好的，让我们这里回想下，我们写的程序。我们的系统一般会分为以下三层，在这里我们把每一个层级对应的java bean都以不同对的名字分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表现层-VO&lt;/li&gt;
&lt;li&gt;业务层-BO&lt;/li&gt;
&lt;li&gt;持久层-DO&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;在这里我想聊一个java最基础的java bean的理解。<br>&emsp;&emsp;作为一个java程序员，java bean有get set仿佛是天经地义的。我也是这样认为的。然而经过高人提点，我们仿佛忽略了一个问题，我们一直在使用orm框架，其实set get是orm框架所必须的。其实我们可以看jdk源码，我们能看到jdk的java bean里全有get set吗？明显不是，反而用的多的也是被我们经常忽略的构造函数。<br>&emsp;&emsp;java bean应该有行为吗？答案是肯定的，java是面向对象的语言，java bean的行为正是其面向对象语言的最主要的特征。好的，让我们这里回想下，我们写的程序。我们的系统一般会分为以下三层，在这里我们把每一个层级对应的java bean都以不同对的名字分类：</p><ol><li>表现层-VO</li><li>业务层-BO</li><li>持久层-DO</li></ol><a id="more"></a><p>持久层就是对应的数据库的层级（Dao），里面会有对应数据库的DO。可以想想，我们一般是不会在DO中声明方法的。但是在业务层和表现层中，其实是有一些业务行为的，比如说数据库中存的是以“分”为单位的数字，但是表现成要以元为显示。我猜测啊，大多数程序员会和我一样，把这个方法写一个util或者private方法调用转换。但是我们如果好好思考下，这个行为其实是java bean本身的，放在java bean中更合适。<br>&emsp;&emsp;在这里我只是提出，我们要考虑行为或者逻辑本身应该属于谁，并不是一棒打死的认为逻辑都应该放在java bean当中。思考最重要。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/17/java-bean/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TDD</title>
      <link>http://yoursite.com/2018/03/17/TDD/</link>
      <guid>http://yoursite.com/2018/03/17/TDD/</guid>
      <pubDate>Sat, 17 Mar 2018 10:56:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在学习TDD，说实话对于TDD的应用我还是抱有一定的观望态度的。我先简单介绍下TDD的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个test&lt;/li&gt;
&lt;li&gt;让test可以运行&lt;/li&gt;
&lt;li&gt;重构可以运行的代码  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是做为一个身陷囹圄的码农，我做的最多的是业务系统（讲的通俗一点就是CRUD）。如果我要按照TDD来开发的话，我需要经历什么呢？先写test。光是这里我就觉得很别扭了，我的目标其实很明确，就是写一个insert表的接口，表有对应的数据字段。这里接口的操作和数据模型非常简单明确，我完全可以先写接口，然后用test来验证接口。&lt;br&gt;&amp;emsp;&amp;emsp;仿佛到了这里已经偏离TDD了，TDD本身的意思是”测试驱动开发“，跟我的方式是由本质区别的。想到这里，我也就明白了，对于简单的业务系统来说，TDD可能并不是太适用。但是对于算法或者比较复杂的业务的时候，可能就比较适用了。我们的架构师在这里对我们的测试题目有了一个不错的分&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;最近在学习TDD，说实话对于TDD的应用我还是抱有一定的观望态度的。我先简单介绍下TDD的过程：</p><ol><li>创建一个test</li><li>让test可以运行</li><li>重构可以运行的代码  </li></ol><p>但是做为一个身陷囹圄的码农，我做的最多的是业务系统（讲的通俗一点就是CRUD）。如果我要按照TDD来开发的话，我需要经历什么呢？先写test。光是这里我就觉得很别扭了，我的目标其实很明确，就是写一个insert表的接口，表有对应的数据字段。这里接口的操作和数据模型非常简单明确，我完全可以先写接口，然后用test来验证接口。<br>&emsp;&emsp;仿佛到了这里已经偏离TDD了，TDD本身的意思是”测试驱动开发“，跟我的方式是由本质区别的。想到这里，我也就明白了，对于简单的业务系统来说，TDD可能并不是太适用。但是对于算法或者比较复杂的业务的时候，可能就比较适用了。我们的架构师在这里对我们的测试题目有了一个不错的分<br><a id="more"></a><br>析，当我们在考虑比较复杂的算法和业务的时候，我们往往不太知道自己该如何下手，仿佛要考虑的地方非常多，怎么入手感觉也不是十分合适（可能这时我们脑子里就把设计模式过了一遍）。其实这个时候就非常适合TDD了，它以最简单的方式入手，不断的是完善，最终给了我们一个不错的设计。<br>&emsp;&emsp;这里就带来一个问题，你觉得好的架构是一开始就设计出来的吗？架构师如此问我们。其实都是慢慢演化而来的，而往往这种演化而来的架构才是最经得起考验的。我们的设计也是一样，如果在一开始我们就各种考虑去应用各种设计模式，反而会过度设计带来反面效果。而如果按照TDD的方式开发，可以防止我们过度设计，我觉得这正是TDD最可贵的地方。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/17/TDD/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
