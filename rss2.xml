<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>永远的万事屋</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>做海贼王的油腻男人</description>
    <pubDate>Fri, 09 Feb 2018 07:55:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>maven-classifier</title>
      <link>http://yoursite.com/2018/02/09/maven-classifier/</link>
      <guid>http://yoursite.com/2018/02/09/maven-classifier/</guid>
      <pubDate>Fri, 09 Feb 2018 04:17:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&amp;emsp;&amp;emsp;在一个大型公司当中，对项目的最最主要的要求就是稳定，任何的改动尽可能的是其影响的范围缩小到最小。改动其实是难免的，只要有需求的任何变化，项目或多或少都会有改动。maven作为一个项目的管理工具，他使用model来实现分层，理想的情况下每个模块内部的类
        
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;在一个大型公司当中，对项目的最最主要的要求就是稳定，任何的改动尽可能的是其影响的范围缩小到最小。改动其实是难免的，只要有需求的任何变化，项目或多或少都会有改动。maven作为一个项目的管理工具，他使用model来实现分层，理想的情况下每个模块内部的类只影响到自己个module本身。例如我们的项目，原则上至少会分成以下几个module，dao、biz、rpc、service、api。<br>&emsp;&emsp;假设我们我们的业务中有一个student表，所以我们dao module会有一个StudentEntity的pojo，如果严格按照原则的话，那我们至少有三个pojo（service是api的一个实现算一个）来表达这个student业务，需要做至少两次convert才最终到service提供出去服务（暂时不包括rpc module），这样才做到了控制影响范围。但是这样带来的一个后果就是，我们的每个module里都会有大量的convert代码，然而其实绝大多数每个module 的pojo之间差别是很小的，甚至是没有任何差别的。所以我们一般做项目的时候都会做一些权衡，有一些东西是可以贯穿整个项目的，比如说自定义的BusinessException、一些constants、一些enum。但是项目module之间的依赖是顺序传递的，如下图:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------+     +-----+     +-----+</span><br><span class="line">| service | --&gt; | biz | --&gt; | dao |</span><br><span class="line">+---------+     +-----+     +-----+</span><br><span class="line">  |               |</span><br><span class="line">  |               |</span><br><span class="line">  v               v</span><br><span class="line">+---------+     +-----+</span><br><span class="line">|   api   |     | rpc |</span><br><span class="line">+---------+     +-----+</span><br></pre></td></tr></table></figure></p><p>我们如何做到使最外层的依赖，让里层获取到呢？例如，api 里面的StudentTypeEnum如何让biz使用呢？<br>&emsp;&emsp;在这里我们定下来回想一下，我们分层的目的是什么？是为了，当我们有任何改动的时候只影响到本层内，不会扩散到其他层。所以我们的依赖是顺序的，里层引用不到和它隔层的类，但是如果我们打破这个顺序，这样每个module之间都可以相互引用，这样其实module也失去了存在的意义。但是我们的需求又是实际存在的，这好像是个矛盾的命题，貌似是不能兼顾双方的。<br>&emsp;&emsp;但maven给了我们解决方案，以往我们使用maven管理jar的时候，只是应用到版本号，但其实在版本号下面还有classifier的分级，同一个版本号但是classifier不同其jar包的内容也是不同的。所以我们如果要解决这个问题，就需要将api打包成两个不同的classifier给其引用，例如classifier分别为all和model，service可以引用all的，biz给其引用model的，这样既防止了biz层的乱用，又使其可以不用写大量重复的convert代码，不过至于哪些类应该给里层使用，这个应该考虑好，也不要过度放开。下面是一些打包的代码，可以借鉴：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;all&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;classifier&gt;all&lt;/classifier&gt;</span><br><span class="line">                            &lt;includes&gt;</span><br><span class="line">                                &lt;include&gt;**&lt;/include&gt;</span><br><span class="line">                            &lt;/includes&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;model&lt;/id&gt;</span><br><span class="line">                        &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt;</span><br><span class="line">                        &lt;phase&gt;package&lt;/phase&gt;</span><br><span class="line">                        &lt;configuration&gt;</span><br><span class="line">                            &lt;classifier&gt;model&lt;/classifier&gt;</span><br><span class="line">                            &lt;includes&gt;</span><br><span class="line">                                &lt;include&gt;**/apply/soa/api/exceptions/**&lt;/include&gt;</span><br><span class="line">                                &lt;include&gt;**/apply/soa/api/service/**/exceptions/**&lt;/include&gt;</span><br><span class="line">                                &lt;include&gt;**/common/**&lt;/include&gt;</span><br><span class="line">                            &lt;/includes&gt;</span><br><span class="line">                        &lt;/configuration&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br></pre></td></tr></table></figure></p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/02/09/maven-classifier/#disqus_thread</comments>
    </item>
    
    <item>
      <title>parameter-passing</title>
      <link>http://yoursite.com/2018/01/21/parameter-passing/</link>
      <guid>http://yoursite.com/2018/01/21/parameter-passing/</guid>
      <pubDate>Sun, 21 Jan 2018 12:56:37 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&amp;emsp;&amp;emsp;今天看《冒号学堂》的时候，看到里面又提到了关于设计语言的传值方式的问题，我记得大概一两年前我就写过类似的东西，里面也讨论了java的传值方式的问题。时至今日，再次看到这个问题的时候，又有了一些别的理解。&lt;br&gt;&amp;emsp;&amp;emsp;现在java8已
        
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;今天看《冒号学堂》的时候，看到里面又提到了关于设计语言的传值方式的问题，我记得大概一两年前我就写过类似的东西，里面也讨论了java的传值方式的问题。时至今日，再次看到这个问题的时候，又有了一些别的理解。<br>&emsp;&emsp;现在java8已经比较流行了，其中最大的亮点大概就是支持了函数式编程，lambda以及function。这就让我们联想到，究竟什么是函数式编程？如果说java8才支持函数式编程，那java8以前算是什么编程呢？不要着急，以下是我的一些个人理解，在这里写下来。<br>&emsp;&emsp;函数大概大家都知道是什么，其实所谓函数式编程就是要大家像编写函数一样去编程。函数的特点是什么呢？最最重要的就是无副作用。什么叫无副作用呢？就像我们写的数学函数一样，我们的输入一定，输出肯定是一样的！比方说我们定义了一个新的运算规则函数，输入两个自然数，输出一个自然数。比方说输入1和9，会输出11，现实当中会由于我多次调用这个函数，然后我输入1和9，输入就变成了12吗？绝对不会！说来也算惭愧，其实我们经常写的代码就会有这种类似的问题。java是在2014年才正式支持这个特性。java8之前也算是铁杆的命令式编程语言吧，但是现在随着硬件水平的提高，命令式编程语言的优点不是那么明显了，相反函数式编程更加适合这个多核高并发的时代，所以最为流行语言的佼佼者，java也不得不跟随时代的潮流，支持函数式编程的特性。<br>&emsp;&emsp;说了这多，跟文章的开头貌似已经偏离了，但是真正的才在这里。众所周知，java传递参数的方式是“值传递”，所谓值传递就是copy一份参数的值传给方法。网上有无数的文章说明了：如果参数是基本变量，无论方法内如何对这个变量赋值，是不能修改这个变量的值的；如果是引用变量，倒是可以修改引用对应实体的参数的值。java是如何实现的，以及内部是怎么处理的，咱们不在这里讨论（这里有一片不错的文章<a href="http://blog.csdn.net/javazejian/article/details/51192130" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/51192130</a>大家可以去这里看）。我这里想说的是，java为什么这样设计呢？改变入参会有什么问题吗？细心的人已经看出来了，就如同我上面对函数式编程做的铺垫一样，java其实也是想规避程序员写出的代码出现上述情况，所以这个算不算java在设计之初就借鉴了函数式编程的思想呢？或者本来没有什么命令式和函数式之分，语言的发展演变就是这样的呢？5年以后的java还会和命令式有多少联系呢？</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/21/parameter-passing/#disqus_thread</comments>
    </item>
    
    <item>
      <title>修复面子工程</title>
      <link>http://yoursite.com/2018/01/01/enchance-blog/</link>
      <guid>http://yoursite.com/2018/01/01/enchance-blog/</guid>
      <pubDate>Mon, 01 Jan 2018 05:48:32 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&amp;emsp;&amp;emsp;做出来的blog满怀欣喜的给别人看，然而居然被说“太难看”。excuse me？做为一个尤其看重内在的人，但更为看重外表的人，怎么能被其他人说难看呢？果断找修复面子的方案。&lt;br&gt;&amp;emsp;&amp;emsp;看到网上的推荐next主题得分最高，所以果断选
        
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;做出来的blog满怀欣喜的给别人看，然而居然被说“太难看”。excuse me？做为一个尤其看重内在的人，但更为看重外表的人，怎么能被其他人说难看呢？果断找修复面子的方案。<br>&emsp;&emsp;看到网上的推荐next主题得分最高，所以果断选择了next主题，按照文档修复了一波。并且也借此机会了解了一些常识，比如tags、categories的运用，比如分页的运用，还比如rss的小知识点。这个是不错的使用next的小知识点，对于初学者很实用：<a href="https://www.jianshu.com/p/5d5931289c09" target="_blank" rel="noopener">link</a>。<br>&emsp;&emsp;anyway，最后真的好看很多，很欣慰元旦这天没白忙。黑白永远不会过时。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/01/01/enchance-blog/#disqus_thread</comments>
    </item>
    
    <item>
      <title>白杨blog的开端文章</title>
      <link>http://yoursite.com/2017/12/27/hello-new-blog/</link>
      <guid>http://yoursite.com/2017/12/27/hello-new-blog/</guid>
      <pubDate>Tue, 26 Dec 2017 16:00:00 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;想做个人博客已经很久了，最近的这种想法尤其的强烈，所以动手做了这个自己的个人博客。下面说一下我做这个的历程。&lt;br&gt;&amp;emsp;&amp;emsp;最开始以前就听说过github支持免费的host服务，所以开始寻找github的支持，很容易找到了github pages的支持。按照官方给出的教程，五分钟时间搞定了首个github pages的“hello world”，然后后面看到了github pages的搭建blog的官方推荐“jekyll”。很高兴能有官方推荐的技术，这样能节省一大部分找对应技术方案的时间，而且能少走弯路，毕竟我还是信任github的（微笑脸）。&lt;br&gt;&amp;emsp;&amp;emsp;其实我对前端的认识还保留在jquery（最近了解了vue）的时代，我认为我好多的工作还是需要写页面的，例如部个局或者写个css样式啥的，所以我果断的安装了我认为非常流行的前端idea webstorm，然而并没有如我所愿，自从安装之后并没有使用过（微笑脸）。然后开始了我的jekyll之旅，对于一个使用windows的用户（而且使用的windows7）来说，对于任何官方文档只提供了linux和mac的技术来说是很痛苦的。找了大量的文章并且尝试了几次安装之后，总归是把jekyll以及需要的ruby环境安装好了。对照着jekyll的官方文档，也写出了一个post demo，直到现在也开始对这种技术有了一些了解，就是把markdown编写的内容动态渲染成html页面展示，只需要少许的配置，因为有默认的主题也不需要关心页面布局什么的，还真的是非常方便的。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;想做个人博客已经很久了，最近的这种想法尤其的强烈，所以动手做了这个自己的个人博客。下面说一下我做这个的历程。<br>&emsp;&emsp;最开始以前就听说过github支持免费的host服务，所以开始寻找github的支持，很容易找到了github pages的支持。按照官方给出的教程，五分钟时间搞定了首个github pages的“hello world”，然后后面看到了github pages的搭建blog的官方推荐“jekyll”。很高兴能有官方推荐的技术，这样能节省一大部分找对应技术方案的时间，而且能少走弯路，毕竟我还是信任github的（微笑脸）。<br>&emsp;&emsp;其实我对前端的认识还保留在jquery（最近了解了vue）的时代，我认为我好多的工作还是需要写页面的，例如部个局或者写个css样式啥的，所以我果断的安装了我认为非常流行的前端idea webstorm，然而并没有如我所愿，自从安装之后并没有使用过（微笑脸）。然后开始了我的jekyll之旅，对于一个使用windows的用户（而且使用的windows7）来说，对于任何官方文档只提供了linux和mac的技术来说是很痛苦的。找了大量的文章并且尝试了几次安装之后，总归是把jekyll以及需要的ruby环境安装好了。对照着jekyll的官方文档，也写出了一个post demo，直到现在也开始对这种技术有了一些了解，就是把markdown编写的内容动态渲染成html页面展示，只需要少许的配置，因为有默认的主题也不需要关心页面布局什么的，还真的是非常方便的。<br><a id="more"></a><br>&emsp;&emsp;我也记不清了找什么关于jekyll的文章，搜索到了类似“jekyll和hexo”的文章，作为一个有学习欲望的小白，虽然和我要找的内容不相关，我还是点击了进去。然而这也开启了，真正的主角hexo的上场。文章里大概讲的就是以下几点：1.jekyll的编译相比hexo很慢 2.jekyll的环境很复杂 3.jekyll的主题很难看。所以作为一个有好奇心的青年，还是去验证一下网上说的事实（在这时候，其实jekyll还是给了我一些视野的，我没想到blog居然还能这样写）。安装了node.js，环境安装完毕，果然环境简单。做出一个demo来看，默认的主题果然比jekyll好看些（个人观点哈哈哈）。至于编译速度没有太大感觉，毕竟我也只做了demo。以下说一下我的个人观点，jekyll依赖于ruby环境，而ruby作为一个后端语言，前端并不是其擅长的，而node.js大家都清楚的哈虽然也是后端语言。<br>&emsp;&emsp;然后我就用hexo搭建了这个blog，虽然还有很多的地方不太会用。例如tag的使用。还有对这个的思考，如果以后blog文章很多的话，那会不会把所有的文章都列举在首页，那首页是不是就会很长？不管如何，我的个人blog今天算是迈出了第一步。哦对了，今天晚上去参加了我们7fresh第一个店铺的开业仪式，很多好吃的，然后现在出完回来补完了这个博客。那个谁谁谁也曾说，好的开端是成功的一半，那是不是我已经成功了一半啦啦啦。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2017/12/27/hello-new-blog/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
