<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>永远的万事屋</title>
    <link>http://yoursite.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>做海贼王的油腻男人</description>
    <pubDate>Fri, 23 Mar 2018 14:50:40 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>websocket http</title>
      <link>http://yoursite.com/2018/03/23/http/</link>
      <guid>http://yoursite.com/2018/03/23/http/</guid>
      <pubDate>Fri, 23 Mar 2018 12:52:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;前端时间和斌哥吃饭，我就斌哥他们做游戏用的是什么通信协议，斌哥说他们用的是websocket。关于websocket的名字我也是听说过的，但也只是了解到了它是http之上的协议，也没有做过深入的理解。这两天闲下来写，所以就查找了websocket了的资料。&lt;br&gt;&amp;emsp;&amp;emsp;既然提到了websocket，http就不能绕过去的。websocket的出现就是为了弥补http的不足。我们都知道一个事实，http协议只能由客户端发起，就是说服务器不能主动向客户端发起请求。但是websocket就是一个&lt;strong&gt;全双工&lt;/strong&gt;协议，允许服务器主动发送信息给客户端。websocket本身是html5规范的一部分，就是来解决服务器给浏览器发消息的问题（原来只能依靠不断的轮询服务器才能做到的事情），但websocket也不局限于浏览器的使用，任何实现了websocket协议的客户端和服务端都可以用此通信。那么websocket到底和http有啥关系呢？websocket和http都是从tcp之上演化而来的，对于websocket来说，它依赖了http协议进行一次握手（关于为啥非得用http握手我就不太清楚了，可能是最先html5的规范并且肯定要在浏览器使用的原因吧），握手成功后，数据就从tcp通道传输，与http无关了。&lt;br&gt;&amp;emsp;&amp;emsp;下面我们来聊一聊http，http的历史发展我就不再多说了，网上很多资料写的很清楚，&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;前端时间和斌哥吃饭，我就斌哥他们做游戏用的是什么通信协议，斌哥说他们用的是websocket。关于websocket的名字我也是听说过的，但也只是了解到了它是http之上的协议，也没有做过深入的理解。这两天闲下来写，所以就查找了websocket了的资料。<br>&emsp;&emsp;既然提到了websocket，http就不能绕过去的。websocket的出现就是为了弥补http的不足。我们都知道一个事实，http协议只能由客户端发起，就是说服务器不能主动向客户端发起请求。但是websocket就是一个<strong>全双工</strong>协议，允许服务器主动发送信息给客户端。websocket本身是html5规范的一部分，就是来解决服务器给浏览器发消息的问题（原来只能依靠不断的轮询服务器才能做到的事情），但websocket也不局限于浏览器的使用，任何实现了websocket协议的客户端和服务端都可以用此通信。那么websocket到底和http有啥关系呢？websocket和http都是从tcp之上演化而来的，对于websocket来说，它依赖了http协议进行一次握手（关于为啥非得用http握手我就不太清楚了，可能是最先html5的规范并且肯定要在浏览器使用的原因吧），握手成功后，数据就从tcp通道传输，与http无关了。<br>&emsp;&emsp;下面我们来聊一聊http，http的历史发展我就不再多说了，网上很多资料写的很清楚，<br><a id="more"></a><a href="http://www.360doc.com/content/16/0816/07/30578693_583526011.shtml" title="http的前世今生" target="_blank" rel="noopener">http://www.360doc.com/content/16/0816/07/30578693_583526011.shtml</a>。这里聊聊我的一些困惑。首先现在最最流行的肯定就是http2了，而http2有很多优秀的特性，像服务端推送、header压缩、二进制格式、多路复用等。其他的特性还很容易理解，这里我最困惑的是<strong>多路复用</strong>，因为我知道http1.1就已经有了keep-alive属性，本身已经做到了不是每次都去创建http连接，而是复用上次的连接，而tcp本身的特性也决定了，只能在一次请求完成以后才能进行下一次请求，这也才有了“<strong>head of line blocking</strong>”问题，在我的理解当中，除非tcp本身解决此问题，否则在其之上的更不可能解决的吧？？<br>&emsp;&emsp;在查找资料的过程中，我也了解到了不少知识，http1.1本身也曾试着解决“head of line blocking”问题，所以提出了http piplelining解决方案，但可能其本身提出的并不是和合理，所以各大浏览器厂商支持并不好<a href="http://www.cnblogs.com/gzchenjiajun-php/articles/4992795.html" target="_blank" rel="noopener">http://www.cnblogs.com/gzchenjiajun-php/articles/4992795.html</a>。这更让我想知道http2是如何解决的呢？方式很简单，将消息分解为更小的独立部分（stream）并通过连接发送。其实tcp本身的特性是没变的，只不过是将消息分解成多份，每部分之间不会相互阻塞，原来发送一个大的请求阻塞的其他请求的情况大大减少。requset stream和response stream是在一个tcp连接上交织在一起的，多个stream构成一个完整的request或者response，但是服务器或者浏览器只能处理完整的请求或者响应，不可能处理一部分的，所以还有另一个事情需要浏览器和服务器去做，那就是将stream重新组装，发送给浏览器渲染或者server的handler处理。以下是我的对于http2对request和response处理的理解：<img src="https://i.imgur.com/ZzO0cGi.png" alt="requset、response分解组装"><br><strong><em>特别注意：以上的请求是发生在一个tcp连接上的，以及request的stream和response的stream都是交织的，在这里是想展示分解、组装的过程。</em></strong><br>&emsp;&emsp;这里我提出一点我的疑问，这个分解组装的过程应该也是增大了客户端和服务端的工作量了吧，但可能是这点消耗对于好处来说是无关紧要的吧。以上是我对于http2以及websocket的理解，不对的话欢迎指教。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/23/http/#disqus_thread</comments>
    </item>
    
    <item>
      <title>java bean</title>
      <link>http://yoursite.com/2018/03/17/java-bean/</link>
      <guid>http://yoursite.com/2018/03/17/java-bean/</guid>
      <pubDate>Sat, 17 Mar 2018 11:28:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;在这里我想聊一个java最基础的java bean的理解。&lt;br&gt;&amp;emsp;&amp;emsp;作为一个java程序员，java bean有get set仿佛是天经地义的。我也是这样认为的。然而经过高人提点，我们仿佛忽略了一个问题，我们一直在使用orm框架，其实set get是orm框架所必须的。其实我们可以看jdk源码，我们能看到jdk的java bean里全有get set吗？明显不是，反而用的多的也是被我们经常忽略的构造函数。&lt;br&gt;&amp;emsp;&amp;emsp;java bean应该有行为吗？答案是肯定的，java是面向对象的语言，java bean的行为正是其面向对象语言的最主要的特征。好的，让我们这里回想下，我们写的程序。我们的系统一般会分为以下三层，在这里我们把每一个层级对应的java bean都以不同对的名字分类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表现层-VO&lt;/li&gt;
&lt;li&gt;业务层-BO&lt;/li&gt;
&lt;li&gt;持久层-DO&lt;/li&gt;
&lt;/ol&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;在这里我想聊一个java最基础的java bean的理解。<br>&emsp;&emsp;作为一个java程序员，java bean有get set仿佛是天经地义的。我也是这样认为的。然而经过高人提点，我们仿佛忽略了一个问题，我们一直在使用orm框架，其实set get是orm框架所必须的。其实我们可以看jdk源码，我们能看到jdk的java bean里全有get set吗？明显不是，反而用的多的也是被我们经常忽略的构造函数。<br>&emsp;&emsp;java bean应该有行为吗？答案是肯定的，java是面向对象的语言，java bean的行为正是其面向对象语言的最主要的特征。好的，让我们这里回想下，我们写的程序。我们的系统一般会分为以下三层，在这里我们把每一个层级对应的java bean都以不同对的名字分类：</p><ol><li>表现层-VO</li><li>业务层-BO</li><li>持久层-DO</li></ol><a id="more"></a><p>持久层就是对应的数据库的层级（Dao），里面会有对应数据库的DO。可以想想，我们一般是不会在DO中声明方法的。但是在业务层和表现层中，其实是有一些业务行为的，比如说数据库中存的是以“分”为单位的数字，但是表现成要以元为显示。我猜测啊，大多数程序员会和我一样，把这个方法写一个util或者private方法调用转换。但是我们如果好好思考下，这个行为其实是java bean本身的，放在java bean中更合适。<br>&emsp;&emsp;在这里我只是提出，我们要考虑行为或者逻辑本身应该属于谁，并不是一棒打死的认为逻辑都应该放在java bean当中。思考最重要。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/17/java-bean/#disqus_thread</comments>
    </item>
    
    <item>
      <title>TDD</title>
      <link>http://yoursite.com/2018/03/17/TDD/</link>
      <guid>http://yoursite.com/2018/03/17/TDD/</guid>
      <pubDate>Sat, 17 Mar 2018 10:56:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;最近在学习TDD，说实话对于TDD的应用我还是抱有一定的观望态度的。我先简单介绍下TDD的过程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个test&lt;/li&gt;
&lt;li&gt;让test可以运行&lt;/li&gt;
&lt;li&gt;重构可以运行的代码  &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是做为一个身陷囹圄的码农，我做的最多的是业务系统（讲的通俗一点就是CRUD）。如果我要按照TDD来开发的话，我需要经历什么呢？先写test。光是这里我就觉得很别扭了，我的目标其实很明确，就是写一个insert表的接口，表有对应的数据字段。这里接口的操作和数据模型非常简单明确，我完全可以先写接口，然后用test来验证接口。&lt;br&gt;&amp;emsp;&amp;emsp;仿佛到了这里已经偏离TDD了，TDD本身的意思是”测试驱动开发“，跟我的方式是由本质区别的。想到这里，我也就明白了，对于简单的业务系统来说，TDD可能并不是太适用。但是对于算法或者比较复杂的业务的时候，可能就比较适用了。我们的架构师在这里对我们的测试题目有了一个不错的分&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;最近在学习TDD，说实话对于TDD的应用我还是抱有一定的观望态度的。我先简单介绍下TDD的过程：</p><ol><li>创建一个test</li><li>让test可以运行</li><li>重构可以运行的代码  </li></ol><p>但是做为一个身陷囹圄的码农，我做的最多的是业务系统（讲的通俗一点就是CRUD）。如果我要按照TDD来开发的话，我需要经历什么呢？先写test。光是这里我就觉得很别扭了，我的目标其实很明确，就是写一个insert表的接口，表有对应的数据字段。这里接口的操作和数据模型非常简单明确，我完全可以先写接口，然后用test来验证接口。<br>&emsp;&emsp;仿佛到了这里已经偏离TDD了，TDD本身的意思是”测试驱动开发“，跟我的方式是由本质区别的。想到这里，我也就明白了，对于简单的业务系统来说，TDD可能并不是太适用。但是对于算法或者比较复杂的业务的时候，可能就比较适用了。我们的架构师在这里对我们的测试题目有了一个不错的分<br><a id="more"></a><br>析，当我们在考虑比较复杂的算法和业务的时候，我们往往不太知道自己该如何下手，仿佛要考虑的地方非常多，怎么入手感觉也不是十分合适（可能这时我们脑子里就把设计模式过了一遍）。其实这个时候就非常适合TDD了，它以最简单的方式入手，不断的是完善，最终给了我们一个不错的设计。<br>&emsp;&emsp;这里就带来一个问题，你觉得好的架构是一开始就设计出来的吗？架构师如此问我们。其实都是慢慢演化而来的，而往往这种演化而来的架构才是最经得起考验的。我们的设计也是一样，如果在一开始我们就各种考虑去应用各种设计模式，反而会过度设计带来反面效果。而如果按照TDD的方式开发，可以防止我们过度设计，我觉得这正是TDD最可贵的地方。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/17/TDD/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于接口的设计</title>
      <link>http://yoursite.com/2018/03/17/work-summary2/</link>
      <guid>http://yoursite.com/2018/03/17/work-summary2/</guid>
      <pubDate>Sat, 17 Mar 2018 09:39:11 GMT</pubDate>
      <description>
      
        &lt;p&gt;&amp;emsp;&amp;emsp;这些天我们正在准备重新规划商户的接口，同事们出了一版设计，但是遭到了我们老大的否定，但是我本身也是比较赞同同事的设计的。矛盾点是在这里：&lt;br&gt;&amp;emsp;&amp;emsp;我认为，我们作为提供基础数据服务的部门，因为我们基本是最上游系统，所以我认为我们这边应该尽量少的包含业务，尽量使我们的接口更好的通用化，至于下游系统怎么使用我们的数据做它自己的业务，我觉得我们并不太需要去关心。这里我们只拿一个接口我说明，&lt;code&gt;Vender getVender(String code, int type)&lt;/code&gt;&lt;br&gt;比如说type有两种，1代表供应商、2代表联营商，按照我上面所说的理由接口设计出来应该是这样的。&lt;br&gt;&amp;emsp;&amp;emsp;我们老大认为，作为服务的提供方（server）首先应该站在调用方（client）去考虑，绝大多数的下游系统只是存储一个code信息，他自己一般是知道自己是什么类型的商户，所以他如果使用这个接口就必须传一个1或者2，这个对于客户端来说就不是很友好。这样这个判断类型的逻辑就分散到了各个调用&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;这些天我们正在准备重新规划商户的接口，同事们出了一版设计，但是遭到了我们老大的否定，但是我本身也是比较赞同同事的设计的。矛盾点是在这里：<br>&emsp;&emsp;我认为，我们作为提供基础数据服务的部门，因为我们基本是最上游系统，所以我认为我们这边应该尽量少的包含业务，尽量使我们的接口更好的通用化，至于下游系统怎么使用我们的数据做它自己的业务，我觉得我们并不太需要去关心。这里我们只拿一个接口我说明，<code>Vender getVender(String code, int type)</code><br>比如说type有两种，1代表供应商、2代表联营商，按照我上面所说的理由接口设计出来应该是这样的。<br>&emsp;&emsp;我们老大认为，作为服务的提供方（server）首先应该站在调用方（client）去考虑，绝大多数的下游系统只是存储一个code信息，他自己一般是知道自己是什么类型的商户，所以他如果使用这个接口就必须传一个1或者2，这个对于客户端来说就不是很友好。这样这个判断类型的逻辑就分散到了各个调用<br><a id="more"></a><br>端，如果以后有了任何的业务变化，比如说判断什么类型的逻辑不是根据这个type了，需要多个if判断才能确定，而这个时候作为服务端的我们如何去推动调用端去改动就太困难了，尤其是身在一个大公司内。到这里我们可以去考虑一个问题，这段逻辑是不是属于我们服务端本身？？其实我们略加思考就可以考虑到，这段逻辑其实是属于服务端本身的，发放到下游确实有些不合适。所以我们重新规划了我们接口的设计:<code>Supplier getSupplier(String code); Associates getAssociates(String code);</code><br>&emsp;&emsp;在这里我们多少几句，其实每一个原则都是辩证来看的，多个原则在一起必然会有矛盾，就比如上面，那是不是我们提供出去的接口都要个性化呢？当然不是，如果所有的都个性化，那我们的接口就会爆炸。我们一定要思考，这个接口的个性化是不是符合我们大的业务框架？站在对方的角度思考下。<br>&emsp;&emsp;如果人生没有了思考，那我们比咸鱼差不了多少。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/17/work-summary2/#disqus_thread</comments>
    </item>
    
    <item>
      <title>关于接口对接</title>
      <link>http://yoursite.com/2018/03/04/work-summary1/</link>
      <guid>http://yoursite.com/2018/03/04/work-summary1/</guid>
      <pubDate>Sun, 04 Mar 2018 07:23:11 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&amp;emsp;&amp;emsp;接口的对接一定要深入了解对方的需求，不仅仅是满足需求就好。&lt;br&gt;&amp;emsp;&amp;emsp;如果对方提出一个需求，正确的态度是要和对方多了解下对方的场景，对方能提供的入参和对方想要的出参。正好你有一个接口可以满足这个需求，但这个时候不要就立刻给出对方这
        
      
      </description>
      
      <content:encoded><![CDATA[<p>&emsp;&emsp;接口的对接一定要深入了解对方的需求，不仅仅是满足需求就好。<br>&emsp;&emsp;如果对方提出一个需求，正确的态度是要和对方多了解下对方的场景，对方能提供的入参和对方想要的出参。正好你有一个接口可以满足这个需求，但这个时候不要就立刻给出对方这个接口，我们一定要经过自己的思考，这个接口是否真正的合适对方，是否需要再提供另一个接口给对方使用呢？？？<br>案例：<br>&emsp;&emsp;商户物资的一个接口需要查询商户信息，其实物资接口只需要商户主要信息的id，但是调用了商户基本信息查询接口，其实此接口内部查询了包含主要信息以及其他七部分信息的数据，其实这个接口对于物资就不太合适。在分布式系统中，各个系统都是相互调用的，接口之间的调用其实都是一个调用链条，其中任何节点的效率都会影响到其之后所有的调用节点，这样越在后面的调用节点，其实是之前节点的影响效率的累加，越是上层的接口影响越是深远，所以不光是接口的设计很重要，对于接口的理解也十分重要。</p>]]></content:encoded>
      
      <comments>http://yoursite.com/2018/03/04/work-summary1/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
